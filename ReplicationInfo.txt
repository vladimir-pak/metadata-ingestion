В target_db будет лежать следующая информация:
Схема: postgres_metadata.

Таблицы:

1. dabatase_metadata.
CREATE TABLE postgres_metadata.database_metadata (
	uuid varchar not null,
	fqn varchar(100) NOT NULL,
	service_name varchar(100) not null,
	"data" jsonb NULL,
	hash_data varchar(500) NULL,
	created_at timestamp NULL,
	CONSTRAINT database_metadata_pk PRIMARY KEY (uuid)
);
Содержание data (jsonb):
{
    "name": "database_example",
    "fqn": "service_name.database_example",
    "parent_fqn": "service_name" <-- наименование сервиса
}

2. schema_metadata
CREATE TABLE postgres_metadata.schema_metadata (
	uuid varchar not null,
	fqn varchar(200) NOT NULL,
	service_name varchar(100) not null,
    db_name varchar(200) not null,
	"data" jsonb NULL,
	hash_data varchar(500) NULL,
	created_at timestamp NULL,
	CONSTRAINT schema_metadata_pk PRIMARY KEY (uuid)
);
Содержание data (jsonb):
{
    "name": "schema_example",
    "fqn": "service_name.database_example.schema_example",
    "parent_fqn": "service_name.database_example" <-- fqn базы данных
}

3. table_metadata
CREATE TABLE postgres_metadata.table_metadata (
	uuid varchar not null,
	fqn varchar(200) NOT NULL,
	service_name varchar(100) not null,
    db_name varchar(200) not null,
    schema_name varchar(200) not null,
	"data" jsonb NULL,
	hash_data varchar(500) NULL,
	created_at timestamp NULL,
	CONSTRAINT table_metadata_pk PRIMARY KEY (uuid)
);
Содержание data (jsonb):
{
    "name": "table_example",
    "fqn": "service_name.database_example.schema_example.table_example",
    "columns": [
        {
            "fqn": "service_name.database_example.schema_example.table_example.column1",
            "dtype": "varchar",
            "dataLength": 100,
            "description": "column description"
        },
        {
            "fqn": "service_name.database_example.schema_example.table_example.column2",
            "dtype": "int4",
            "dataLength": null,
            "description": "column description"
        }
    ],
    "parent_fqn": "service_name.database_example.schema_example" <-- fqn схемы
}

Сервис будет константой - подается в теле запроса на обновление кэша. Будет состоять из 3 символов (ORD, MKD и пр.)


ЛОГИКА СВЕРКИ КЭША.

При первой загрузке в кэше орды (в runtime) не будет ничего лежать - пустая мапа.
Сервис проверяет на пустоту мапу (кэш орды). Если пусто, то это считается инициализирующей загрузкой, иначе - инкрементальная загрузка.

Инициализирующая загрузка.
Сервис идет в базу данных (target_db), формирует кэш из базы.
Из базы нужно будет брать записи по фильтру:
postgres_metadata.database_metadata.service_name = service_name - полученный в теле запроса http.
postgres_metadata.schema_metadata.service_name = service_name - полученный в теле запроса http.
postgres_metadata.table_metadata.service_name = service_name - полученный в теле запроса http.

Будет 3 кэша:
1. DatabaseCache = {
    "090a49f0-7ce0-4946-8073-6a4aece511f4": {
        "data": {...}, <-- атрибут data из postgres_metadata.database_metadata
        "hash_data": "some hash" <-- hash сумма по атрибуту data
    }
}
Ключ - uuid для базы данных

2. SchemaCache = {
    "cce86062-37fd-4a28-88a1-8c2f8be24470": {
        "data": {...}, <-- атрибут data из postgres_metadata.schema_metadata
        "hash_data": "some hash" <-- hash сумма по атрибуту data
    }
}
Ключ - uuid для схемы

3. TableCache = {
    "098e3d52-92f8-49f0-8d8a-2a97b04003e9": {
        "data": {...}, <-- атрибут data из postgres_metadata.table_metadata
        "hash_data": "some hash" <-- hash сумма по атрибуту data
    }
}
Ключ - uuid для таблицы

Отправляет все в орду, не осуществляя сверки, методом PUT.
Затем весь кэш из базы отправляет в кэш орды (в runtime).

Инкрементальная загрузка.
Сервис идет в базу данных (target_db), формирует кэш из базы такой же как и выше.
Сверяемся с кэшем орды (runtime) по ключу мапы и hash_data.
3 возможных сценария при сверке:
1. Если ключ из кэша базы не найден в кэше орды - это новая мапа, новая сущность. Отправляем на добавление сущности (POST/PUT).
2. Если ключ из кэша орды не найден в кэше базы - это удаленная сущность. Отправляем на удаление сущности (DELETE).
3. Если ключ найден в обеих мапах, но hash_data отличается - это измененная сущность. Отправляем на изменение (PUT).

Иначе - ничего не делаем с сущностью, изменений нет.
После всего перечисленного перезаписываем кэш орды.

